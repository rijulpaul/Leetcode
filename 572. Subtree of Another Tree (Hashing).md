## Problem: [572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)

### Difficulty:
*Easy*

### Topics:
*Tree | String Matching | Depth-First Search | Binary Tree | Hash Function*

---

### Description:
Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

---

### Approach:
I implemented a custom polynomial rolling hash for each subtree and replaced each node’s value with its hash.
By computing a unique hash for subRoot, I could traverse root and check for any node with a matching hash — indicating identical structure and values.
- **Time Complexity:** O(n)
- **Space Complexity:** O(1)

---

### Solution:
```cpp
class Solution {
    const int MOD = 1e9 + 7;
    const int A = 1000003, B = 1000033, C = 1000211, D = 13331;

    int hashify(TreeNode* node) {
        if (!node) return 3;

        int left = hashify(node->left);
        int right = hashify(node->right);

        long long h = (1LL * A * node->val % MOD +
                       1LL * B * left % MOD +
                       1LL * C * right % MOD + D) % MOD;

        node->val = static_cast<int>(h);
        return node->val;
    }

    bool find(TreeNode* node, int targetHash) {
        if (!node) return false;
        if (node->val == targetHash) return true;
        return find(node->left, targetHash) || find(node->right, targetHash);
    }

public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        int targetHash = hashify(subRoot);
        hashify(root);
        return find(root, targetHash);
    }
};
```
