## Problem: [39. Combination Sum](https://leetcode.com/problems/combination-sum/)

### Difficulty:
*Medium*

### Topics:
*Array | Backtracking*

---

### Description:
Given an array of integers and a target. Return a an array of set of integers whose sum is equal to the target.

---

### Approach:
Use DFS with backtracking to explore all combinations where numbers sum to target.
At each step:
- If target < 0 → stop exploring (prune branch).
- If target == 0 → store current combination.
- Else, try all candidates starting from index (to allow reuse of same number).
Avoids creating new vectors at each recursive call by modifying in-place (push_back / pop_back).
- **Time Complexity:** O(2^n)
- **Space Complexity:** O(n)

---

### Solution:
```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> result;
        vector<int> path;
        backtrack(candidates, target, 0, path, result);
        return result;
    }

private:
    void backtrack(vector<int>& candidates, int target, int start,
                   vector<int>& path, vector<vector<int>>& result) {
        if (target == 0) {
            result.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); ++i) {
            if (candidates[i] > target) continue; // pruning
            path.push_back(candidates[i]);
            backtrack(candidates, target - candidates[i], i, path, result); // reuse same element
            path.pop_back();
        }
    }
};
```
