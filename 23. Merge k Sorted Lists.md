
## Problem: [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

### Difficulty:
*Hard*

### Topics:
*Linked List | Divide and Conquer | Heap | Merge Sort*

---

### Description:
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.

---

### Approach:
Use a priority_queue (min-heap) with a custom comparator to store only the heads of each list. Repeatedly pop the smallest node, attach it to the result, and push its next node if it exists. This avoids manually handling make_heap, push_heap, and pop_heap.
- **Time Complexity:** O(N log k)
- **Space Complexity:** O(k)

---

### Solution:
```cpp
class Solution {
public:
    struct Compare {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val; // Min-heap
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, Compare> pq;

        for (auto node : lists) {
            if (node) pq.push(node);
        }

        ListNode dummy(0);
        ListNode* tail = &dummy;

        while (!pq.empty()) {
            ListNode* smallest = pq.top();
            pq.pop();

            tail->next = smallest;
            tail = tail->next;

            if (smallest->next) pq.push(smallest->next);
        }

        return dummy.next;
    }
};
```
